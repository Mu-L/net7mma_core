using Media.Codec.Jpeg.Classes;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.Arm;
using System.Runtime.Intrinsics.X86;

namespace Codec.Jpeg.Classes;

//Based on https://github.com/SixLabors/ImageSharp/blob/21ec18e1b1186c3f1d549269271177d4516b3ba5/src/ImageSharp/Formats/Jpeg/Components/FloatingPointDCT.cs

/// <summary>
/// Contains floating point forward and inverse DCT implementations
/// </summary>
/// <remarks>
/// Based on "Arai, Agui and Nakajima" algorithm.
/// </remarks>
internal static class DiscreteCosineTransformation
{
    #region Static Vectors

    private static readonly Vector4 mm128_F_0_7071 = new(0.707106781f);
    private static readonly Vector4 mm128_F_0_3826 = new(0.382683433f);
    private static readonly Vector4 mm128_F_0_5411 = new(0.541196100f);
    private static readonly Vector4 mm128_F_1_3065 = new(1.306562965f);

    private static readonly Vector4 mm128_F_1_4142 = new(1.414213562f);
    private static readonly Vector4 mm128_F_1_8477 = new(1.847759065f);
    private static readonly Vector4 mm128_F_n1_0823 = new(-1.082392200f);
    private static readonly Vector4 mm128_F_n2_6131 = new(-2.613125930f);

    #endregion

    #region Static Tables

    /// <summary>
    /// Gets adjustment table for quantization tables.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Current IDCT and FDCT implementations are based on  Arai, Agui,
    /// and Nakajima's algorithm. Both DCT methods does not
    /// produce finished DCT output, final step is fused into the
    /// quantization step. Quantization and de-quantization coefficients
    /// must be multiplied by these values.
    /// </para>
    /// <para>
    /// Given values were generated by formula:
    /// <code>
    /// scalefactor[row] * scalefactor[col], where
    /// scalefactor[0] = 1
    /// scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
    /// </code>
    /// </para>
    /// </remarks>
    private static readonly float[] AdjustmentCoefficients =
    [
        1f, 1.3870399f, 1.306563f, 1.1758755f, 1f, 0.78569496f, 0.5411961f, 0.27589938f,
        1.3870399f, 1.9238797f, 1.812255f, 1.6309863f, 1.3870399f, 1.0897902f, 0.7506606f, 0.38268346f,
        1.306563f, 1.812255f, 1.707107f, 1.5363555f, 1.306563f, 1.02656f, 0.7071068f, 0.36047992f,
        1.1758755f, 1.6309863f, 1.5363555f, 1.3826833f, 1.1758755f, 0.9238795f, 0.63637924f, 0.32442334f,
        1f, 1.3870399f, 1.306563f, 1.1758755f, 1f, 0.78569496f, 0.5411961f, 0.27589938f,
        0.78569496f, 1.0897902f, 1.02656f, 0.9238795f, 0.78569496f, 0.61731654f, 0.42521507f, 0.21677275f,
        0.5411961f, 0.7506606f, 0.7071068f, 0.63637924f, 0.5411961f, 0.42521507f, 0.29289323f, 0.14931567f,
        0.27589938f, 0.38268346f, 0.36047992f, 0.32442334f, 0.27589938f, 0.21677275f, 0.14931567f, 0.076120466f,
    ];

    #endregion

    #region Static Methods

    /// <summary>
    /// Adjusts given quantization table for usage with <see cref="TransformIDCT"/>.
    /// </summary>
    /// <param name="quantTable">Quantization table to adjust.</param>
    public static void AdjustToIDCT(Block quantTable)
    {
        ref float tableRef = ref Unsafe.As<byte, float>(ref quantTable.Array[quantTable.Offset]);
        ref float multipliersRef = ref MemoryMarshal.GetReference<float>(AdjustmentCoefficients);
        for (nuint i = 0, e = (nuint)quantTable.FloatLength; i < e; i++)
        {
            ref float elemRef = ref Unsafe.Add(ref tableRef, i);
            elemRef = 0.125f * elemRef * Unsafe.Add(ref multipliersRef, i);
        }

        // Spectral macroblocks are transposed before quantization
        // so we must transpose quantization table
        quantTable.TransposeInplace();
    }

    /// <summary>
    /// Adjusts given quantization table for usage with <see cref="TransformFDCT"/>.
    /// </summary>
    /// <param name="quantTable">Quantization table to adjust.</param>
    public static void AdjustToFDCT(Block quantTable)
    {
        ref float tableRef = ref Unsafe.As<byte, float>(ref quantTable.Array[quantTable.Offset]);
        ref float multipliersRef = ref MemoryMarshal.GetReference<float>(AdjustmentCoefficients);
        for (nuint i = 0, e = (nuint)quantTable.FloatLength; i < e; i++)
        {
            ref float elemRef = ref Unsafe.Add(ref tableRef, i);
            elemRef = 0.125f / (elemRef * Unsafe.Add(ref multipliersRef, i));
        }

        // Spectral macroblocks are not transposed before quantization
        // Transpose is done after quantization at zig-zag stage
        // so we must transpose quantization table
        quantTable.TransposeInplace();
    }

    /// <summary>
    /// Apply 2D floating point IDCT inplace.
    /// </summary>
    /// <remarks>
    /// Input block must be dequantized with quantization table
    /// adjusted by <see cref="AdjustToIDCT"/>.
    /// </remarks>
    /// <param name="block">Input block.</param>
    public static void TransformIDCT(Block block)
    {
        if (Avx.IsSupported)
        {
            IDCT8x8_Avx(block);
        }
        else
        {
            IDCT_Vector4(block);
        }
    }

    /// <summary>
    /// Apply 2D floating point IDCT inplace.
    /// </summary>
    /// <remarks>
    /// Input block must be quantized after this method with quantization
    /// table adjusted by <see cref="AdjustToFDCT"/>.
    /// </remarks>
    /// <param name="block">Input block.</param>
    public static void TransformFDCT(Block block)
    {
        if (Avx.IsSupported)
        {
            FDCT8x8_Avx(block);
        }
        else
        {
            FDCT_Vector4(block);
        }
    }

    /// <summary>
    /// Apply floating point FDCT inplace using simd operations.
    /// </summary>
    /// <param name="block">Input block.</param>
    private static void FDCT8x8_Avx(Block block)
    {
        // First pass - process columns
        FDCT8x8_1D_Avx(block);

        // Second pass - process rows
        block.TransposeInplace();
        FDCT8x8_1D_Avx(block);

        // Applies 1D floating point FDCT inplace
        static void FDCT8x8_1D_Avx(Block block)
        {
            Vector256<float> tmp0 = Avx.Add(block.V0f, block.V7f);
            Vector256<float> tmp7 = Avx.Subtract(block.V0f, block.V7f);
            Vector256<float> tmp1 = Avx.Add(block.V1f, block.V6f);
            Vector256<float> tmp6 = Avx.Subtract(block.V1f, block.V6f);
            Vector256<float> tmp2 = Avx.Add(block.V2f, block.V5f);
            Vector256<float> tmp5 = Avx.Subtract(block.V2f, block.V5f);
            Vector256<float> tmp3 = Avx.Add(block.V3f, block.V4f);
            Vector256<float> tmp4 = Avx.Subtract(block.V3f, block.V4f);

            // Even part
            Vector256<float> tmp10 = Avx.Add(tmp0, tmp3);
            Vector256<float> tmp13 = Avx.Subtract(tmp0, tmp3);
            Vector256<float> tmp11 = Avx.Add(tmp1, tmp2);
            Vector256<float> tmp12 = Avx.Subtract(tmp1, tmp2);

            block.V0f = Avx.Add(tmp10, tmp11);
            block.V4f = Avx.Subtract(tmp10, tmp11);

            var mm256_F_0_7071 = Vector256.Create(0.707106781f);
            Vector256<float> z1 = Avx.Multiply(Avx.Add(tmp12, tmp13), mm256_F_0_7071);
            block.V2f = Avx.Add(tmp13, z1);
            block.V6f = Avx.Subtract(tmp13, z1);

            // Odd part
            tmp10 = Avx.Add(tmp4, tmp5);
            tmp11 = Avx.Add(tmp5, tmp6);
            tmp12 = Avx.Add(tmp6, tmp7);

            Vector256<float> z5 = Avx.Multiply(Avx.Subtract(tmp10, tmp12), Vector256.Create(0.382683433f));         // mm256_F_0_3826
            Vector256<float> z2 = MultiplyAdd(z5, Vector256.Create(0.541196100f), tmp10);    // mm256_F_0_5411
            Vector256<float> z4 = MultiplyAdd(z5, Vector256.Create(1.306562965f), tmp12);    // mm256_F_1_3065
            Vector256<float> z3 = Avx.Multiply(tmp11, mm256_F_0_7071);

            Vector256<float> z11 = Avx.Add(tmp7, z3);
            Vector256<float> z13 = Avx.Subtract(tmp7, z3);

            block.V5f = Avx.Add(z13, z2);
            block.V3f = Avx.Subtract(z13, z2);
            block.V1f = Avx.Add(z11, z4);
            block.V7f = Avx.Subtract(z11, z4);
        }
    }

    /// <summary>
    /// Performs a multiplication and an addition of the <see cref="Vector256{Single}"/>.
    /// TODO: Fix. The arguments are in a different order to the FMA intrinsic.
    /// </summary>
    /// <remarks>ret = (vm0 * vm1) + va</remarks>
    /// <param name="va">The vector to add to the intermediate result.</param>
    /// <param name="vm0">The first vector to multiply.</param>
    /// <param name="vm1">The second vector to multiply.</param>
    /// <returns>The <see cref="Vector256{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector256<float> MultiplyAdd(
        Vector256<float> va,
        Vector256<float> vm0,
        Vector256<float> vm1)
    {
        if (Fma.IsSupported)
        {
            return Fma.MultiplyAdd(vm1, vm0, va);
        }

        return Avx.Add(Avx.Multiply(vm0, vm1), va);
    }

    /// <summary>
    /// Performs a multiplication and a subtraction of the <see cref="Vector256{Single}"/>.
    /// </summary>
    /// <remarks>ret = (vm0 * vm1) - vs</remarks>
    /// <param name="vm1">The second vector to multiply.</param>
    /// <param name="vm0">The first vector to multiply.</param>
    /// <param name="vs">The vector to subtract from the intermediate result.</param>
    /// <returns>The <see cref="Vector256{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector256<float> MultiplySubtract(
        Vector256<float> vm1,
        Vector256<float> vm0,
        Vector256<float> vs)
    {
        if (Fma.IsSupported)
        {
            return Fma.MultiplySubtract(vm1, vm0, vs);
        }

        return Avx.Subtract(Avx.Multiply(vm0, vm1), vs);
    }

    /// <summary>
    /// Performs a multiplication and a negated addition of the <see cref="Vector256{Single}"/>.
    /// </summary>
    /// <remarks>ret = c - (a * b)</remarks>
    /// <param name="a">The first vector to multiply.</param>
    /// <param name="b">The second vector to multiply.</param>
    /// <param name="c">The vector to add negated to the intermediate result.</param>
    /// <returns>The <see cref="Vector256{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector256<float> MultiplyAddNegated(
        Vector256<float> a,
        Vector256<float> b,
        Vector256<float> c)
    {
        if (Fma.IsSupported)
        {
            return Fma.MultiplyAddNegated(a, b, c);
        }

        return Avx.Subtract(c, Avx.Multiply(a, b));
    }

    /// <summary>
    /// Performs a multiplication and an addition of the <see cref="Vector128{Single}"/>.
    /// </summary>
    /// <remarks>ret = (vm0 * vm1) + va</remarks>
    /// <param name="vm1">The second vector to multiply.</param>
    /// <param name="vm0">The first vector to multiply.</param>
    /// <param name="va">The vector to add to the intermediate result.</param>
    /// <returns>The <see cref="Vector256{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector128<float> MultiplyAdd(
        Vector128<float> vm1,
        Vector128<float> vm0,
        Vector128<float> va)
    {
        if (Fma.IsSupported)
        {
            return Fma.MultiplyAdd(vm1, vm0, va);
        }

        if (AdvSimd.IsSupported)
        {
            return AdvSimd.Add(AdvSimd.Multiply(vm0, vm1), va);
        }

        return Sse.Add(Sse.Multiply(vm0, vm1), va);
    }


    /// <summary>
    /// Apply floating point IDCT inplace using simd operations.
    /// </summary>
    /// <param name="transposedBlock">Transposed input block.</param>
    private static void IDCT8x8_Avx(Block transposedBlock)
    {
        // First pass - process columns
        IDCT8x8_1D_Avx(transposedBlock);

        // Second pass - process rows
        transposedBlock.TransposeInplace();
        IDCT8x8_1D_Avx(transposedBlock);

        // Applies 1D floating point FDCT inplace
        static void IDCT8x8_1D_Avx(Block block)
        {
            // Even part
            Vector256<float> tmp0 = block.V0f;
            Vector256<float> tmp1 = block.V2f;
            Vector256<float> tmp2 = block.V4f;
            Vector256<float> tmp3 = block.V6f;

            Vector256<float> z5 = tmp0;
            Vector256<float> tmp10 = Avx.Add(z5, tmp2);
            Vector256<float> tmp11 = Avx.Subtract(z5, tmp2);

            var mm256_F_1_4142 = Vector256.Create(1.414213562f);
            Vector256<float> tmp13 = Avx.Add(tmp1, tmp3);
            Vector256<float> tmp12 = MultiplySubtract(mm256_F_1_4142, Avx.Subtract(tmp1, tmp3), tmp13);

            tmp0 = Avx.Add(tmp10, tmp13);
            tmp3 = Avx.Subtract(tmp10, tmp13);
            tmp1 = Avx.Add(tmp11, tmp12);
            tmp2 = Avx.Subtract(tmp11, tmp12);

            // Odd part
            Vector256<float> tmp4 = block.V1f;
            Vector256<float> tmp5 = block.V3f;
            Vector256<float> tmp6 = block.V5f;
            Vector256<float> tmp7 = block.V7f;

            Vector256<float> z13 = Avx.Add(tmp6, tmp5);
            Vector256<float> z10 = Avx.Subtract(tmp6, tmp5);
            Vector256<float> z11 = Avx.Add(tmp4, tmp7);
            Vector256<float> z12 = Avx.Subtract(tmp4, tmp7);

            tmp7 = Avx.Add(z11, z13);
            tmp11 = Avx.Multiply(Avx.Subtract(z11, z13), mm256_F_1_4142);

            z5 = Avx.Multiply(Avx.Add(z10, z12), Vector256.Create(1.847759065f));                   // mm256_F_1_8477

            tmp10 = MultiplyAdd(z5, z12, Vector256.Create(-1.082392200f));   // mm256_F_n1_0823
            tmp12 = MultiplyAdd(z5, z10, Vector256.Create(-2.613125930f));   // mm256_F_n2_6131

            tmp6 = Avx.Subtract(tmp12, tmp7);
            tmp5 = Avx.Subtract(tmp11, tmp6);
            tmp4 = Avx.Subtract(tmp10, tmp5);

            block.V0f = Avx.Add(tmp0, tmp7);
            block.V7f = Avx.Subtract(tmp0, tmp7);
            block.V1f = Avx.Add(tmp1, tmp6);
            block.V6f = Avx.Subtract(tmp1, tmp6);
            block.V2f = Avx.Add(tmp2, tmp5);
            block.V5f = Avx.Subtract(tmp2, tmp5);
            block.V3f = Avx.Add(tmp3, tmp4);
            block.V4f = Avx.Subtract(tmp3, tmp4);
        }
    }

    /// <summary>
    /// Apply floating point IDCT inplace using <see cref="Vector4"/> API.
    /// </summary>
    /// <remarks>
    /// This method can be used even if there's no SIMD intrinsics available
    /// as <see cref="Vector4"/> can be compiled to scalar instructions.
    /// </remarks>
    /// <param name="transposedBlock">Input block.</param>
    private static void IDCT_Vector4(Block transposedBlock)
    {
        // First pass - process columns
        var vectorLeft = transposedBlock.V0L;
        var vectorRight = transposedBlock.V0R;
        IDCT8x4_Vector4(ref vectorLeft);
        IDCT8x4_Vector4(ref vectorRight);
        
        // Second pass - process rows
        transposedBlock.TransposeInplace();
        IDCT8x4_Vector4(ref vectorLeft);
        IDCT8x4_Vector4(ref vectorRight);

        transposedBlock.V0L = vectorLeft;
        transposedBlock.V0R = vectorRight;

        // Applies 1D floating point IDCT inplace on 8x4 part of 8x8 block
        static void IDCT8x4_Vector4(ref Vector4 vecRef)
        {
            // Even part
            Vector4 tmp0 = Unsafe.Add(ref vecRef, 0 * 2);
            Vector4 tmp1 = Unsafe.Add(ref vecRef, 2 * 2);
            Vector4 tmp2 = Unsafe.Add(ref vecRef, 4 * 2);
            Vector4 tmp3 = Unsafe.Add(ref vecRef, 6 * 2);

            Vector4 z5 = tmp0;
            Vector4 tmp10 = z5 + tmp2;
            Vector4 tmp11 = z5 - tmp2;

            Vector4 tmp13 = tmp1 + tmp3;
            Vector4 tmp12 = ((tmp1 - tmp3) * mm128_F_1_4142) - tmp13;

            tmp0 = tmp10 + tmp13;
            tmp3 = tmp10 - tmp13;
            tmp1 = tmp11 + tmp12;
            tmp2 = tmp11 - tmp12;

            // Odd part
            Vector4 tmp4 = Unsafe.Add(ref vecRef, 1 * 2);
            Vector4 tmp5 = Unsafe.Add(ref vecRef, 3 * 2);
            Vector4 tmp6 = Unsafe.Add(ref vecRef, 5 * 2);
            Vector4 tmp7 = Unsafe.Add(ref vecRef, 7 * 2);

            Vector4 z13 = tmp6 + tmp5;
            Vector4 z10 = tmp6 - tmp5;
            Vector4 z11 = tmp4 + tmp7;
            Vector4 z12 = tmp4 - tmp7;

            tmp7 = z11 + z13;
            tmp11 = (z11 - z13) * mm128_F_1_4142;

            z5 = (z10 + z12) * mm128_F_1_8477;

            tmp10 = (z12 * mm128_F_n1_0823) + z5;
            tmp12 = (z10 * mm128_F_n2_6131) + z5;

            tmp6 = tmp12 - tmp7;
            tmp5 = tmp11 - tmp6;
            tmp4 = tmp10 - tmp5;

            Unsafe.Add(ref vecRef, 0 * 2) = tmp0 + tmp7;
            Unsafe.Add(ref vecRef, 7 * 2) = tmp0 - tmp7;
            Unsafe.Add(ref vecRef, 1 * 2) = tmp1 + tmp6;
            Unsafe.Add(ref vecRef, 6 * 2) = tmp1 - tmp6;
            Unsafe.Add(ref vecRef, 2 * 2) = tmp2 + tmp5;
            Unsafe.Add(ref vecRef, 5 * 2) = tmp2 - tmp5;
            Unsafe.Add(ref vecRef, 3 * 2) = tmp3 + tmp4;
            Unsafe.Add(ref vecRef, 4 * 2) = tmp3 - tmp4;
        }
    }

    /// <summary>
    /// Apply floating point FDCT inplace using <see cref="Vector4"/> API.
    /// </summary>
    /// <param name="block">Input block.</param>
    private static void FDCT_Vector4(Block block)
    {
        // First pass - process columns
        var vectorLeft = block.V0L;
        var vectorRight = block.V0R;
        FDCT8x4_Vector4(ref vectorLeft);
        FDCT8x4_Vector4(ref vectorRight);

        // Second pass - process rows
        block.TransposeInplace();
        FDCT8x4_Vector4(ref vectorLeft);
        FDCT8x4_Vector4(ref vectorRight);

        block.V0L = vectorLeft;
        block.V0R = vectorRight;

        // Applies 1D floating point FDCT inplace on 8x4 part of 8x8 block
        static void FDCT8x4_Vector4(ref Vector4 vecRef)
        {
            Vector4 tmp0 = Unsafe.Add(ref vecRef, 0) + Unsafe.Add(ref vecRef, 14);
            Vector4 tmp7 = Unsafe.Add(ref vecRef, 0) - Unsafe.Add(ref vecRef, 14);
            Vector4 tmp1 = Unsafe.Add(ref vecRef, 2) + Unsafe.Add(ref vecRef, 12);
            Vector4 tmp6 = Unsafe.Add(ref vecRef, 2) - Unsafe.Add(ref vecRef, 12);
            Vector4 tmp2 = Unsafe.Add(ref vecRef, 4) + Unsafe.Add(ref vecRef, 10);
            Vector4 tmp5 = Unsafe.Add(ref vecRef, 4) - Unsafe.Add(ref vecRef, 10);
            Vector4 tmp3 = Unsafe.Add(ref vecRef, 6) + Unsafe.Add(ref vecRef, 8);
            Vector4 tmp4 = Unsafe.Add(ref vecRef, 6) - Unsafe.Add(ref vecRef, 8);

            // Even part
            Vector4 tmp10 = tmp0 + tmp3;
            Vector4 tmp13 = tmp0 - tmp3;
            Vector4 tmp11 = tmp1 + tmp2;
            Vector4 tmp12 = tmp1 - tmp2;

            Unsafe.Add(ref vecRef, 0) = tmp10 + tmp11;
            Unsafe.Add(ref vecRef, 8) = tmp10 - tmp11;

            Vector4 z1 = (tmp12 + tmp13) * mm128_F_0_7071;
            Unsafe.Add(ref vecRef, 4) = tmp13 + z1;
            Unsafe.Add(ref vecRef, 12) = tmp13 - z1;

            // Odd part
            tmp10 = tmp4 + tmp5;
            tmp11 = tmp5 + tmp6;
            tmp12 = tmp6 + tmp7;

            Vector4 z5 = (tmp10 - tmp12) * mm128_F_0_3826;
            Vector4 z2 = (mm128_F_0_5411 * tmp10) + z5;
            Vector4 z4 = (mm128_F_1_3065 * tmp12) + z5;
            Vector4 z3 = tmp11 * mm128_F_0_7071;

            Vector4 z11 = tmp7 + z3;
            Vector4 z13 = tmp7 - z3;

            Unsafe.Add(ref vecRef, 10) = z13 + z2;
            Unsafe.Add(ref vecRef, 6) = z13 - z2;
            Unsafe.Add(ref vecRef, 2) = z11 + z4;
            Unsafe.Add(ref vecRef, 14) = z11 - z4;
        }
    }

    #endregion
}
